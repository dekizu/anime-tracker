<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Seasonal Anime Tracker</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect } = React;

    function App() {
      const [anime, setAnime] = useState([]);
      const [loading, setLoading] = useState(true);
      const [selectedDay, setSelectedDay] = useState('All');
      const [searchTerm, setSearchTerm] = useState('');
      const [watchedEpisodes, setWatchedEpisodes] = useState({});
      const [bookmarkedAnime, setBookmarkedAnime] = useState(new Set());
      const [notifications, setNotifications] = useState(new Set());
      const [showBookmarkedOnly, setShowBookmarkedOnly] = useState(false);
      const [selectedSeason, setSelectedSeason] = useState('ALL');
      const [selectedYear, setSelectedYear] = useState(2026);
      const [error, setError] = useState(null);

      const days = ['All', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
      const seasons = [
        { value: 'ALL', label: 'All', emoji: 'üåç' },
        { value: 'WINTER', label: 'Winter', emoji: '‚ùÑÔ∏è' },
        { value: 'SPRING', label: 'Spring', emoji: 'üå∏' },
        { value: 'SUMMER', label: 'Summer', emoji: '‚òÄÔ∏è' },
        { value: 'FALL', label: 'Fall', emoji: 'üçÇ' }
      ];
      const years = [2024, 2025, 2026, 2027];

      useEffect(() => {
        loadUserData();
      }, []);

      useEffect(() => {
        fetchSeasonalAnime();
      }, [selectedSeason, selectedYear, showBookmarkedOnly]);

      const loadUserData = () => {
        try {
          const watched = JSON.parse(localStorage.getItem('watchedEpisodes') || '{}');
          const bookmarked = new Set(JSON.parse(localStorage.getItem('bookmarkedAnime') || '[]'));
          const notifs = new Set(JSON.parse(localStorage.getItem('notifications') || '[]'));
          
          setWatchedEpisodes(watched);
          setBookmarkedAnime(bookmarked);
          setNotifications(notifs);
        } catch (e) {
          console.error('Error loading user data:', e);
        }
      };

      const saveUserData = (watched, bookmarked, notifs) => {
        try {
          localStorage.setItem('watchedEpisodes', JSON.stringify(watched));
          localStorage.setItem('bookmarkedAnime', JSON.stringify([...bookmarked]));
          localStorage.setItem('notifications', JSON.stringify([...notifs]));
        } catch (e) {
          console.error('Error saving user data:', e);
        }
      };

      const fetchSeasonalAnime = async () => {
        setLoading(true);
        setError(null);
        
        try {
          console.log('Fetching anime via API proxy...', { selectedSeason, selectedYear, showBookmarkedOnly });
          
          // If showing bookmarked only
          if (showBookmarkedOnly) {
            if (bookmarkedAnime.size === 0) {
              setAnime([]);
              setLoading(false);
              return;
            }

            const bookmarkedIds = Array.from(bookmarkedAnime);
            const query = `
              query {
                Page(page: 1, perPage: 100) {
                  media(id_in: [${bookmarkedIds.join(',')}], type: ANIME) {
                    id
                    title {
                      english
                      romaji
                    }
                    episodes
                    nextAiringEpisode {
                      episode
                      airingAt
                    }
                    coverImage {
                      large
                      color
                    }
                    averageScore
                    description
                    genres
                    airingSchedule(notYetAired: false, perPage: 1) {
                      nodes {
                        airingAt
                        episode
                      }
                    }
                  }
                }
              }
            `;

            const response = await fetch('https://corsproxy.io/?' + encodeURIComponent('https://graphql.anilist.co'), {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({ 
                query: query.trim()
              }),
            });

            if (!response.ok) {
              throw new Error('Failed to fetch bookmarked anime');
            }

            const data = await response.json();
            
            if (data.errors) {
              throw new Error(data.errors[0].message);
            }

            const processedAnime = data.data.Page.media.map(a => {
              const airingTime = a.nextAiringEpisode?.airingAt || a.airingSchedule?.nodes[0]?.airingAt;
              const currentEp = a.nextAiringEpisode?.episode ? a.nextAiringEpisode.episode - 1 : 
                               a.airingSchedule?.nodes[0]?.episode || 1;
              
              const indonesianDate = airingTime ? new Date(airingTime * 1000) : null;
              
              return {
                id: a.id,
                title: a.title.english || a.title.romaji,
                episode: currentEp,
                totalEpisodes: a.episodes,
                nextEpisode: a.nextAiringEpisode?.episode,
                airingAt: airingTime,
                day: indonesianDate ? indonesianDate.toLocaleDateString('en-US', { weekday: 'long', timeZone: 'Asia/Jakarta' }) : 'TBA',
                time: indonesianDate ? indonesianDate.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false, timeZone: 'Asia/Jakarta' }).replace(/^24/, '00') : 'TBA',
                cover: a.coverImage.large,
                color: a.coverImage.color || '#3B82F6',
                score: a.averageScore,
                description: a.description?.replace(/<[^>]*>/g, '').slice(0, 150) + '...' || 'No description available',
                genres: a.genres.slice(0, 3),
              };
            });

            setAnime(processedAnime);
            setLoading(false);
            return;
          }

          // Regular season fetch
          const seasonFilter = selectedSeason === 'ALL' ? '' : `, season: ${selectedSeason}`;
          
          const query = `
            query {
              Page(page: 1, perPage: 100) {
                media(seasonYear: ${selectedYear}${seasonFilter}, type: ANIME, sort: POPULARITY_DESC) {
                  id
                  title {
                    english
                    romaji
                  }
                  episodes
                  nextAiringEpisode {
                    episode
                    airingAt
                  }
                  coverImage {
                    large
                    color
                  }
                  averageScore
                  description
                  genres
                  airingSchedule(notYetAired: false, perPage: 1) {
                    nodes {
                      airingAt
                      episode
                    }
                  }
                }
              }
            }
          `;

          const response = await fetch('https://corsproxy.io/?' + encodeURIComponent('https://graphql.anilist.co'), {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              query: query.trim()
            }),
          });

          if (!response.ok) {
            throw new Error(`API error: ${response.status}`);
          }

          const data = await response.json();
          
          if (data.errors) {
            throw new Error(data.errors[0].message);
          }

          if (!data.data || !data.data.Page || !data.data.Page.media) {
            throw new Error('Invalid response from API');
          }
          
          const processedAnime = data.data.Page.media.map(a => {
            const airingTime = a.nextAiringEpisode?.airingAt || a.airingSchedule?.nodes[0]?.airingAt;
            const currentEp = a.nextAiringEpisode?.episode ? a.nextAiringEpisode.episode - 1 : 
                             a.airingSchedule?.nodes[0]?.episode || 1;
            
            const indonesianDate = airingTime ? new Date(airingTime * 1000) : null;
            
            return {
              id: a.id,
              title: a.title.english || a.title.romaji,
              episode: currentEp,
              totalEpisodes: a.episodes,
              nextEpisode: a.nextAiringEpisode?.episode,
              airingAt: airingTime,
              day: indonesianDate ? indonesianDate.toLocaleDateString('en-US', { weekday: 'long', timeZone: 'Asia/Jakarta' }) : 'TBA',
              time: indonesianDate ? indonesianDate.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false, timeZone: 'Asia/Jakarta' }).replace(/^24/, '00') : 'TBA',
              cover: a.coverImage.large,
              color: a.coverImage.color || '#3B82F6',
              score: a.averageScore,
              description: a.description?.replace(/<[^>]*>/g, '').slice(0, 150) + '...' || 'No description available',
              genres: a.genres.slice(0, 3),
            };
          });

          setAnime(processedAnime);
        } catch (error) {
          console.error('Error fetching anime:', error);
          setError(error.message);
        } finally {
          setLoading(false);
        }
      };

      const toggleWatched = (animeId, episode) => {
        const key = `${animeId}-${episode}`;
        const newWatched = { ...watchedEpisodes };
        
        if (newWatched[key]) {
          delete newWatched[key];
        } else {
          newWatched[key] = true;
        }
        
        setWatchedEpisodes(newWatched);
        saveUserData(newWatched, bookmarkedAnime, notifications);
      };

      const toggleBookmark = (animeId) => {
        const newBookmarked = new Set(bookmarkedAnime);
        if (newBookmarked.has(animeId)) {
          newBookmarked.delete(animeId);
        } else {
          newBookmarked.add(animeId);
        }
        setBookmarkedAnime(newBookmarked);
        saveUserData(watchedEpisodes, newBookmarked, notifications);
      };

      const toggleNotification = (animeId) => {
        const newNotifications = new Set(notifications);
        if (newNotifications.has(animeId)) {
          newNotifications.delete(animeId);
        } else {
          newNotifications.add(animeId);
        }
        setNotifications(newNotifications);
        saveUserData(watchedEpisodes, bookmarkedAnime, newNotifications);
      };

      const filteredAnime = anime.filter(a => {
        const matchesDay = selectedDay === 'All' || a.day === selectedDay;
        const matchesSearch = a.title.toLowerCase().includes(searchTerm.toLowerCase());
        return matchesDay && matchesSearch;
      });

      if (loading) {
        return (
          <div className="min-h-screen bg-gradient-to-br from-black via-blue-900 to-black flex items-center justify-center">
            <div className="text-center">
              <div className="w-16 h-16 mx-auto mb-4">
                <svg className="animate-spin text-blue-400" fill="none" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
              </div>
              <p className="text-white text-lg">Loading seasonal anime...</p>
            </div>
          </div>
        );
      }

      if (error) {
        return (
          <div className="min-h-screen bg-gradient-to-br from-black via-blue-900 to-black flex items-center justify-center p-4">
            <div className="text-center bg-red-500/20 border border-red-500 rounded-lg p-6 max-w-md">
              <p className="text-red-400 text-lg mb-4">Error loading anime</p>
              <p className="text-red-300 text-sm mb-4">{error}</p>
              <button 
                onClick={() => fetchSeasonalAnime()} 
                className="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600"
              >
                Try Again
              </button>
            </div>
          </div>
        );
      }

      return (
        <div className="min-h-screen bg-gradient-to-br from-black via-blue-900 to-black p-4 pb-20">
          <div className="max-w-4xl mx-auto">
            {/* Header */}
            <div className="text-center mb-6 pt-6">
              <div className="flex items-center justify-center gap-3 mb-2">
                <svg className="w-10 h-10 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <rect x="2" y="7" width="20" height="15" rx="2" ry="2"></rect>
                  <polyline points="17 2 12 7 7 2"></polyline>
                </svg>
                <h1 className="text-4xl font-bold text-white">Seasonal Anime</h1>
              </div>
              <p className="text-blue-300">Track Your Seasonal Shows (WIB Time)</p>
            </div>

            {/* Season & Year Selector */}
            <div className="mb-6 bg-slate-800/50 backdrop-blur rounded-lg p-4 border border-blue-500/20">
              <div className="text-sm text-slate-300 mb-3 font-semibold">Select Season:</div>
              <div className="grid grid-cols-5 gap-2 mb-4">
                {seasons.map(season => (
                  <button
                    key={season.value}
                    onClick={() => setSelectedSeason(season.value)}
                    className={`px-3 py-2 rounded-lg transition-all text-sm ${
                      selectedSeason === season.value
                        ? 'bg-blue-500 text-white shadow-lg'
                        : 'bg-slate-700 text-slate-300 hover:bg-slate-600'
                    }`}
                  >
                    <div>{season.emoji}</div>
                    <div className="text-xs">{season.label}</div>
                  </button>
                ))}
              </div>
              <div className="text-sm text-slate-300 mb-2 font-semibold">Select Year:</div>
              <div className="grid grid-cols-4 gap-2">
                {years.map(year => (
                  <button
                    key={year}
                    onClick={() => setSelectedYear(year)}
                    className={`px-3 py-2 rounded-lg transition-all ${
                      selectedYear === year
                        ? 'bg-blue-500 text-white shadow-lg'
                        : 'bg-slate-700 text-slate-300 hover:bg-slate-600'
                    }`}
                  >
                    {year}
                  </button>
                ))}
              </div>
            </div>

            {/* Stats */}
            <div className="grid grid-cols-3 gap-3 mb-6">
              <div className="bg-slate-800/50 backdrop-blur rounded-lg p-3 border border-blue-500/20 text-center">
                <div className="text-2xl font-bold text-white">{anime.length}</div>
                <div className="text-xs text-slate-400">Total Anime</div>
              </div>
              <div className="bg-slate-800/50 backdrop-blur rounded-lg p-3 border border-blue-500/20 text-center">
                <div className="text-2xl font-bold text-blue-400">{bookmarkedAnime.size}</div>
                <div className="text-xs text-slate-400">Bookmarked</div>
              </div>
              <div className="bg-slate-800/50 backdrop-blur rounded-lg p-3 border border-blue-500/20 text-center">
                <div className="text-2xl font-bold text-green-400">{Object.keys(watchedEpisodes).length}</div>
                <div className="text-xs text-slate-400">Watched</div>
              </div>
            </div>

            {/* Search */}
            <div className="mb-4">
              <div className="relative">
                <svg className="absolute left-3 top-3.5 w-5 h-5 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <circle cx="11" cy="11" r="8"></circle>
                  <path d="m21 21-4.35-4.35"></path>
                </svg>
                <input
                  type="text"
                  placeholder="Search anime..."
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                  className="w-full pl-10 pr-4 py-3 rounded-lg bg-slate-800 text-white placeholder-slate-400 border border-blue-500/30 focus:outline-none focus:border-blue-500"
                />
              </div>
            </div>

            <button
              onClick={() => setShowBookmarkedOnly(!showBookmarkedOnly)}
              className={`mb-4 px-4 py-2 rounded-lg transition-all ${
                showBookmarkedOnly ? 'bg-blue-500 text-white' : 'bg-slate-800 text-slate-300'
              }`}
            >
              <span className="inline-block mr-2">üîñ</span>
              {showBookmarkedOnly ? 'Show All' : 'Bookmarked Only'}
            </button>

            {/* Day Filter */}
            <div className="flex gap-2 mb-6 overflow-x-auto pb-2">
              {days.map(day => (
                <button
                  key={day}
                  onClick={() => setSelectedDay(day)}
                  className={`px-4 py-2 rounded-full whitespace-nowrap transition-all ${
                    selectedDay === day
                      ? 'bg-blue-500 text-white shadow-lg shadow-blue-500/50'
                      : 'bg-slate-800 text-slate-300 hover:bg-slate-700'
                  }`}
                >
                  {day}
                </button>
              ))}
            </div>

            {/* Anime List */}
            <div className="space-y-4">
              {filteredAnime.length === 0 ? (
                <div className="text-center py-12 text-slate-400">
                  <p>No anime found</p>
                  {showBookmarkedOnly && <p className="text-sm mt-2">Try bookmarking some anime first!</p>}
                </div>
              ) : (
                filteredAnime.map(a => {
                  const isWatched = watchedEpisodes[`${a.id}-${a.episode}`];
                  const isBookmarked = bookmarkedAnime.has(a.id);
                  const hasNotification = notifications.has(a.id);

                  return (
                    <div
                      key={a.id}
                      className="bg-slate-800/50 backdrop-blur rounded-xl overflow-hidden border border-blue-500/20 hover:border-blue-500/40 transition-all"
                    >
                      <div className="flex gap-4 p-4">
                        {/* Cover */}
                        <div className="w-24 h-32 rounded-lg overflow-hidden flex-shrink-0">
                          <img src={a.cover} alt={a.title} className="w-full h-full object-cover" />
                        </div>

                        {/* Content */}
                        <div className="flex-1 min-w-0">
                          <div className="flex items-start justify-between gap-2 mb-2">
                            <h3 className="text-lg font-semibold text-white leading-tight">{a.title}</h3>
                            <div className="flex gap-1 flex-shrink-0">
                              <button
                                onClick={() => toggleBookmark(a.id)}
                                className={`p-1.5 rounded transition-colors ${
                                  isBookmarked ? 'bg-blue-500 text-white' : 'bg-slate-700 text-slate-400'
                                }`}
                              >
                                üîñ
                              </button>
                              <button
                                onClick={() => toggleNotification(a.id)}
                                className={`p-1.5 rounded transition-colors ${
                                  hasNotification ? 'bg-yellow-500 text-white' : 'bg-slate-700 text-slate-400'
                                }`}
                              >
                                üîî
                              </button>
                            </div>
                          </div>

                          <p className="text-xs text-slate-400 mb-3 line-clamp-2">{a.description}</p>

                          <div className="flex flex-wrap gap-2 mb-3">
                            {a.genres.map(genre => (
                              <span key={genre} className="px-2 py-1 text-xs rounded-full bg-blue-500/20 text-blue-300">
                                {genre}
                              </span>
                            ))}
                          </div>

                          <div className="flex flex-wrap items-center gap-3 text-sm mb-3 text-blue-300">
                            <span>üìÖ {a.day}</span>
                            <span>üïê {a.time}</span>
                            {a.score && <span>‚≠ê {(a.score / 10).toFixed(1)}</span>}
                          </div>

                          <div className="flex items-center gap-2">
                            <button
                              onClick={() => toggleWatched(a.id, a.episode)}
                              className={`flex items-center gap-2 px-3 py-1.5 rounded-lg transition-all ${
                                isWatched ? 'bg-green-500 text-white' : 'bg-slate-700 text-slate-300'
                              }`}
                            >
                              <span>{isWatched ? '‚úì' : '‚óã'}</span>
                              <span className="text-sm">
                                Episode {a.episode}{a.totalEpisodes ? `/${a.totalEpisodes}` : ''}
                              </span>
                            </button>
                            {a.nextEpisode && (
                              <span className="text-xs text-slate-400">
                                Next: Ep {a.nextEpisode}
                              </span>
                            )}
                          </div>
                        </div>
                      </div>
                    </div>
                  );
                })
              )}
            </div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>